GC垃圾回收机制
==

### Go v1.3之前的标记清除
### Go v1.5 三色标记法
### Go v1.8 混合写屏障机制

STW （stop the world）垃圾回收时要暂停所有线程，也是很多语言的性能瓶景之一
#### v1.3之前的标记清除
程序与对象的可达关系，stw时把可达对象做上标记，然后没标记的就回收掉，停止stw,程序继续<br>
缺点：<br>
1. stw,让程序暂停，程序出现卡顿（重要问题）
2. 标记需要扫描整个heap
3. 清除数据会产生碎片

#### v1.5 3色标记法
白色标记表<br>
将所有的对象标记为白色
灰色标记表
遍历灰色，
黑色标记表
从根集合中遍历（root set,只遍历一次），得到灰色结点，然后遍历灰色结点，有可达对象的就将其置为灰色，本身变为黑色<br>
最终灰色标记表中是没有对象的，删除白色对象<br>

在没有stw机制保护的话，会出现白色对象被黑色对象引用，被引用对象被删除。还是需要STW机制保护<br>
条件1. 一个白色对象被黑色对象引用（白色被挂在黑色下）<br>
条件2. 灰色对象与它之间的可达关系的白色对象遭到破坏（灰色同时丢了白色）<br>
以上两个条件同时满足，那么就会出现对象丢失的现象

#### 强弱三色不变式
强三色不变式：强制性不允许黑色对象引用白色对象（破坏条件1）<br> 
弱三色不变式：黑色对象可以引用白色对象，白色对象存在其他灰色对象对它的引用，或者可达它链路的上游存在灰色对象（破坏条件2）<br>

#### 插入写屏障（对象被引用时触发的机制）（不在栈上使用，栈空间需要重新扫描，还需要在栈上加入stw机制扫描）
将B挂在A下游，B必须被标记为灰色（满足强三色不变式）
#### 删除写屏障（对象被删除时触发的机制）
具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色<br>
满足：弱三色不变式（保护灰色对象到白色对象的路径不会断）<br>
不足：回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉<br>

#### 1.8之后的 三色标记法+混合写屏障
具体操作：
1. GC开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次扫描，无序STW）
2. GC期间，任何栈上创建的新对象，均为黑色
3. 被删除对象标记为灰色
4. 被添加的对象标记为灰色
满足来弱三色不变式（结合来插入，删除写屏障的优点）





